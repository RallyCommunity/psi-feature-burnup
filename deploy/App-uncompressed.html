<!DOCTYPE html>
<html>
<head>
    <title>psi-feature-burnup</title>

    <script type="text/javascript" src="/apps/2.0rc2/sdk.js"></script>
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0rc1/lib/analytics/analytics-all.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/async/1.22/async.min.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                var acceptedPointsData = [];
var acceptedCountData = [];
var myMask = null;
var app = null;
var showAssignedProgram = true;

Ext.define('CustomApp', {
    scopeType: 'release',
    extend: 'Rally.app.App',
    componentCls: 'app',

    // switch to app configuration from ui selection
    config: {

        defaultSettings : {
            releases                : "",
            parentQuery             : "",
            parentIds               : "",
            ignoreZeroValues        : true,
            PreliminaryEstimate     : true,
            StoryPoints             : true,
            StoryCount              : false,
            StoryPointsProjection   : true,
            StoryCountProjection    : false,
            AcceptedStoryPoints     : true,
            AcceptedStoryCount      : false,
            AcceptedPointsProjection: true,
            AcceptedCountProjection : false,
            FeatureCount            : false,
            FeatureCountCompleted   : false,
            HistoricalProjection    : false,
            RefinedEstimate : false
        }

    },

    getSettingsFields: function() {

        var checkValues = _.map(createSeriesArray(),function(s) {
            return { name : s.name, xtype : 'rallycheckboxfield', label : s.description};
        });

        var values = [
            {
                name: 'releases',
                xtype: 'rallytextfield',
                label : "Release names to be included (comma seperated)"
            },
            {
                name: 'parentQuery',
                xtype: 'rallytextfield',
                label : "Query for feature parent Portfolio items (will override release selection)"
            },

            {
                name: 'parentIds',
                xtype: 'rallytextfield',
                label : "(Optional) List of Parent PortfolioItem (Epics) ids to filter Features by"
            },

            {
                name: 'ignoreZeroValues',
                xtype: 'rallycheckboxfield',
                label: 'For projection ignore zero values'
            }
        ];

        _.each(values,function(value){
            value.labelWidth = 250;
            value.labelAlign = 'left'
        });

        return values.concat(checkValues);
    },

    launch: function() {

        app = this;
        app.series = createSeriesArray();
        app.configReleases = app.getSetting("releases");
        app.ignoreZeroValues = app.getSetting("ignoreZeroValues");
        app.parentIds = app.getSetting("parentIds");
        app.parentQuery = app.getSetting("parentQuery");

        if ((app.configReleases==="") && (app.parentIds==="")) {
            this.add({html:"Please Configure this app by selecting Edit App Settings from Configure (gear) Menu"});
            return;
        }

        var that = this;
        // get the project id.
        this.project = this.getContext().getProject().ObjectID;

        // get the release (if on a page scoped to the release)
        var tbName = getReleaseTimeBox(this);
        // release selected page will over-ride app config
        app.configReleases = tbName !== "" ? tbName : app.configReleases;

        var releaseFilter = app.createReleaseFilter(app.configReleases);

        var configs = [];
        
        // query for estimate values, releases and iterations.
        configs.push({ model : "PreliminaryEstimate", 
                       fetch : ['Name','ObjectID','Value'], 
                       filters : [] 
        });
        configs.push({ model : "Release",             
                       fetch : ['Name', 'ObjectID', 'Project', 'ReleaseStartDate', 'ReleaseDate' ], 
                       filters: (releaseFilter!==null? [releaseFilter] : [])
        });
        configs.push({ model : "TypeDefinition",
                       fetch : true,
                       filters : [ { property:"Ordinal", operator:"=", value:0} ]
        });

        // get the preliminary estimate type values, and the releases.
        async.map( configs, app.wsapiQuery, function(err,results) {

            app.peRecords   = results[0];
            app.releases    = results[1];
            app.featureType = results[2][0].get("TypePath");

            // choose which strategy to use to filter features.

            if (app.parentIds.split(",")[0] !=="") {
                myMask = new Ext.LoadMask(Ext.getBody(), {msg:"Please wait..."});
                // app.queryEpicFeatures();
                var strategy = Ext.create("FeaturesForParentStrategy", {
                    portfolioIds : app.parentIds,
                    featureType : app.featureType,
                    context : app.getContext()
                });
                strategy.readFeatures( function(results,error) {
                    if (error) {
                        app.add({html:error});
                        return;
                    } else {
                        console.log("Read features",results.features.length,results.extent,results.iterations.length);
                        app.features = results.features;
                        app.iterations = results.iterations;
                        app.extent = results.extent;
                        app.queryFeatureSnapshots();
                    }
                });
            } else {
                app.extent = app.getReleaseExtent(app.releases);
                if (app.releases.length===0) {
                    app.add({html:"No Releases found with this name: "+app.configReleases});
                    return;
                }

                configs = [
                    {
                        model  : "Iteration",
                        fetch  : ['Name', 'ObjectID', 'Project', 'StartDate', 'EndDate' ],
                        filters: app.createIterationFilter(app.releases)
                    }
                ];

                // get the iterations
                async.map( configs, app.wsapiQuery, function(err,results) {
                    app.iterations = results[0];
                    app.queryFeatures();
                });
            }
        });
    },

    // remove leading and trailing spaces
    trimString : function (str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },



    // creates a filter to return all releases with a specified set of names
    createReleaseFilter : function(releaseNames) {

        var filter = null;

        _.each( releaseNames.split(","), function( releaseName, i ) {
            if (releaseName !== "") {
                var f = Ext.create('Rally.data.wsapi.Filter', {
                        property : 'Name', operator : '=', value : app.trimString(releaseName) }
                );
                filter = (i===0) ? f : filter.or(f);
            }
        });

        console.log("Release Filter:",(filter!==null?filter.toString():"not set"));
        return filter;

    },

    createIterationFilter : function(releases) {

        var extent = app.getReleaseExtent(releases);

        var filter = Ext.create('Rally.data.wsapi.Filter', {
            property : 'EndDate', operator: ">=", value: extent.isoStart
        });

        filter = filter.and( Ext.create('Rally.data.wsapi.Filter', {
                property : 'EndDate', operator: "<=", value: extent.isoEnd
            })
        );

        return filter;
    },

    getReleaseExtent : function( releases ) {

        var start = _.min(_.pluck(releases,function(r) { return r.get("ReleaseStartDate");}));
        var end   = _.max(_.pluck(releases,function(r) { return r.get("ReleaseDate");}));
        var isoStart  = Rally.util.DateTime.toIsoString(start, false);
        var isoEnd    = Rally.util.DateTime.toIsoString(end, false);

        return { start : start, end : end, isoStart : isoStart, isoEnd : isoEnd };

    },

    // generic function to perform a web services query    
    wsapiQuery : function( config , callback ) {

        Ext.create('Rally.data.WsapiDataStore', {
            autoLoad : true,
            limit : "Infinity",
            model : config.model,
            fetch : config.fetch,
            filters : config.filters,
            listeners : {
                scope : this,
                load : function(store, data) {
                    callback(null,data);
                }
            }
        });

    },

    queryEpicFeatures : function() {

        myMask = new Ext.LoadMask(Ext.getBody(), {msg:"Please wait..."});

        var filter = null;
        var parentIds = app.parentIds.split(",");

        if (epicIds.length === 0) {
            app.add({html:"No epic id's specified"+app.configReleases});
            return;
        }

        _.each(epicIds, function( epicId, i) {
            var f = Ext.create('Rally.data.QueryFilter', {
                property: 'Parent.FormattedID',
                operator: '=',
                value: epicId
            });
            filter = i === 0 ? f : filter.or(f);
        });

        return Ext.create('Rally.data.WsapiDataStore', {
            autoLoad: true,
            model : app.featureType,
            limit : 'Infinity',
            fetch: ['ObjectID','FormattedID' ],
            filters: [filter],
            listeners: {
                load: function(store, features) {
                    console.log("Loaded:"+features.length," Features.");
                    app.features = features;
                    if (app.features.length === 0) {
                        app.add({html:"No features for parent PortfolioItem :"+app.epicIds});
                        return;
                    } else {
                    app.queryFeatureSnapshots();
                    }
                }
            }
        });        

    },

    queryFeatures : function() {

        myMask = new Ext.LoadMask(Ext.getBody(), {msg:"Please wait..."});
        var filter = null;

        var releaseNames = _.uniq(_.map(app.releases,function(r){ return r.get("Name");}));
        console.log("releaseNames",releaseNames);

        _.each( releaseNames , function( release, i ) {
            var f = Ext.create('Rally.data.QueryFilter', {
                property: 'Release.Name',
                operator: '=',
                value: release
            });
            filter = i === 0 ? f : filter.or(f);
        });

        return Ext.create('Rally.data.WsapiDataStore', {
            autoLoad: true,
//            model: 'PortfolioItem/Feature',
            model : app.featureType,
            limit : 'Infinity',
            fetch: ['ObjectID','FormattedID' ],
            filters: [filter],
            listeners: {
                load: function(store, features) {
                    console.log("Loaded:"+features.length," Features.");
                    app.features = features;
                    if (app.features.length === 0) {
                        app.add({html:"No features in release(s):"+app.configReleases});
                        return;
                    } else {
                    app.queryFeatureSnapshots();
                    }
                }
            }
        });        
    },
    
    queryFeatureSnapshots : function () {

        var ids = _.pluck(app.features, function(feature) { return feature.get("ObjectID");} );
        // var pes = _.pluck(app.features, function(feature) { return feature.get("PreliminaryEstimate");} );
        // var extent = app.getReleaseExtent(app.releases);
        // console.log("ids",ids,pes);

        var storeConfig = {
            find : {
                // '_TypeHierarchy' : { "$in" : ["PortfolioItem/PIFTeam"] },
                'ObjectID' : { "$in" : ids },
                '_ValidTo' : { "$gte" : app.extent.isoStart }
            },
            autoLoad : true,
            pageSize:1000,
            limit: 'Infinity',
            fetch: ['_UnformattedID','ObjectID','_TypeHierarchy','PreliminaryEstimate', 'LeafStoryCount','LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal','AcceptedLeafStoryCount','PercentDoneByStoryCount','RefinedEstimate'],
            hydrate: ['_TypeHierarchy']
        };

        storeConfig.listeners = {
            scope : this,
            load: function(store, snapshots, success) {
                console.log("Loaded:"+snapshots.length," Snapshots.");
                app.createChartData(snapshots);
            }
        };

        var snapshotStore = Ext.create('Rally.data.lookback.SnapshotStore', storeConfig);
    },

    createChartData : function ( snapshots ) {
        
        var that = this;
        var lumenize = window.parent.Rally.data.lookback.Lumenize;
        var snapShotData = _.map(snapshots,function(d){return d.data;});
        var extent = app.getReleaseExtent(app.releases);

        var snaps = _.sortBy(snapShotData,"_UnformattedID");
        // can be used to 'knockout' holidays
        var holidays = [
            //{year: 2014, month: 1, day: 1}  // Made up holiday to test knockout
        ];

        var myCalc = Ext.create("MyBurnCalculator", {
            series : app.series,
            ignoreZeroValues : app.ignoreZeroValues,
            peRecords : app.peRecords
        });

        // calculator config
        var config = {
            deriveFieldsOnInput: myCalc.getDerivedFieldsOnInput(),
            metrics: myCalc.getMetrics(),
            summaryMetricsConfig: [],
            deriveFieldsAfterSummary: myCalc.getDerivedFieldsAfterSummary(),
            granularity: lumenize.Time.DAY,
            tz: 'America/Chicago',
            holidays: holidays,
            workDays: 'Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday'
        };
        // release start and end dates
        var startOnISOString = new lumenize.Time(extent.start).getISOStringInTZ(config.tz);
        var upToDateISOString = new lumenize.Time(extent.end).getISOStringInTZ(config.tz);
        // create the calculator and add snapshots to it.
        calculator = new lumenize.TimeSeriesCalculator(config);
        calculator.addSnapshots(snapShotData, startOnISOString, upToDateISOString);
        
        // create a high charts series config object, used to get the hc series data
        var hcConfig = [{ name : "label" }];
        _.each( app.series, function(s) {
            if ( app.getSetting(s.name)===true) {
                hcConfig.push({
                   name : s.description, type : s.display
                });
            }
        });
        var hc = lumenize.arrayOfMaps_To_HighChartsSeries(calculator.getResults().seriesData, hcConfig);
        this.showChart( trimHighChartsConfig(hc) );
    },

    createPlotLines : function(seriesData) {

        // filter the iterations
        var start = new Date( Date.parse(seriesData[0]));
        var end   = new Date( Date.parse(seriesData[seriesData.length-1]));
        var releaseI = _.filter(this.iterations,function(i) { return i.get("EndDate") >= start && i.get("EndDate") <= end;});
        releaseI = _.uniq(releaseI,function(i) { return i.get("Name");});
        var itPlotLines = _.map(releaseI, function(i){
            var d = new Date(Date.parse(i.raw.EndDate)).toISOString().split("T")[0];
            return {
                label : i.get("Name"),
                dashStyle : "Dot",
                color: 'grey',
                width: 1,
                value: _.indexOf(seriesData,d)
            }; 
        });
        // create release plot lines        
        var rePlotLines = _.map(this.selectedReleases, function(i){
            var d = new Date(Date.parse(i.raw.ReleaseDate)).toISOString().split("T")[0];
            return {
                label : i.get("Name"),
                // dashStyle : "Dot",
                color: 'grey',
                width: 1,
                value: _.indexOf(seriesData,d)
            }; 
        });
        return itPlotLines.concat(rePlotLines);

    },

    showChart : function(series) {

        var that = this;

        // console.log("series",series);
        // console.log("Last Accepted Projection  ",_.last(series[5].data));
        // console.log("Last Historical Projection",_.last(series[6].data));
        
        var chart = this.down("#chart1");
        myMask.hide();
        if (chart !== null)
            chart.removeAll();
            
        // create plotlines
        var plotlines = this.createPlotLines(series[0].data);
        
        // set the tick interval
        var tickInterval = series[1].data.length <= (7*20) ? 7 : (series[1].data.length / 20);

        var extChart = Ext.create('Rally.ui.chart.Chart', {
            columnWidth : 1,
            itemId : "chart1",
            chartData: {
                categories : series[0].data,
                series : series.slice(1, series.length)
            },

            chartColors : createColorsArray(series),

            chartConfig : {
                chart: {
                },
                title: {
                text: 'PSI Feature Burnup ('+ app.configReleases  +')',
                x: -20 //center
                },
                plotOptions: {
                    series: {
                        marker: {
                            radius: 2
                        }
                    }
                },
                xAxis: {
                    plotLines : plotlines,
                    //tickInterval : 7,
                    tickInterval : tickInterval,
                    type: 'datetime',
                    labels: {
                        formatter: function() {
                            return Highcharts.dateFormat('%b %d', Date.parse(this.value));
                        }
                    }
                },
                yAxis: {
                    title: {
                        text : 'Points/Count'
                    },
                    plotLines: [{
                        value: 0,
                        width: 1,
                        color: '#808080'
                    }]
                },
                tooltip: {
                },
                legend: { align: 'center', verticalAlign: 'bottom' }
            }
        });
        this.add(extChart);
        chart = this.down("#chart1");
        var p = Ext.get(chart.id);
        elems = p.query("div.x-mask");
        _.each(elems, function(e) { e.remove(); });
        var elems = p.query("div.x-mask-msg");
        _.each(elems, function(e) { e.remove(); });

    }

});

                Ext.define("MyBurnCalculator", function() {

    var self;

    return {

        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",

        config : {
            series : [],
            ignoreZeroValues : true,
            peRecords : []

        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            return this;
        },

        pointsOffset : [],
        countOffset : [],
        data : [],
        indexOffset : [],

        getMetrics: function () {

            // get the set of non-projection metrics
            var nonProjectionMetrics = _.filter(self.series,function(s) {
               return s.name.indexOf("Projection")==-1;
            });

            var metrics = _.map( nonProjectionMetrics, function(m) {
                return {
                    field : m.field,
                    as : m.description,
                    display : m.display,
                    f : m.f
                };
            });

            return metrics;
        },

        getDerivedFieldsOnInput : function () {
            // XS 1, S 3, M 5, L 8, XL 13
            return [
                {
                    as: 'CalcPreliminaryEstimate',
                    f:  function(row) {
                        var r = _.find(self.peRecords, function(rec) { return rec.get("ObjectID") == row.PreliminaryEstimate; });
                        var v = r !== undefined ? r.get("Value") : 0;
                        return v;
                    }
                },
                {
                    as: 'Completed',
                    f:  function(row) {
                    return row.PercentDoneByStoryCount == 1 ? 1 : 0;
                    }
                }
            ];
        },

        getMidPointIndex : function(dateSeries) {

            var today = new Date();

            var tdi = _.findIndex(dateSeries,function(d) {
                return ( today.setHours(0,0,0,0) === new Date(Date.parse(d)).setHours(0,0,0,0))
            });

            return tdi !== -1 ? Math.round(tdi/2) : -1;

        },

        calcProjectionPoint : function(seriesName,projectOn,row, index, summaryMetrics, seriesData, projectFrom) {

            var that = this;

            // for first point we save the data set on which we are going to do the linear projection on
            // we also optionally filter out values.
            if (index === 0) {
                datesData = _.pluck(seriesData,"label");
                var mid = self.getMidPointIndex(datesData);
                var today = new Date();
                var li = datesData.length-1;

                // that.data[seriesName] = _.pluck(seriesData,seriesName);
                that.data[seriesName] = _.pluck(seriesData,projectOn);
                // if (seriesName==="Story Points") console.log(that.data[seriesName].length);
                // filter to just values before today
                that.data[seriesName] = _.filter(
                    that.data[seriesName], function(d,i) {
                        if (!_.isUndefined(projectFrom) && projectFrom==="mid") {
                            return (i < mid);
                        } else {
                            return new Date(Date.parse(datesData[i])) < today;
                        }
                    }
                );
                // if (seriesName==="Story Points") console.log(that.data[seriesName].length);
                // optionally remove zero values
                var dx = that.data[seriesName].length;
                if (self.ignoreZeroValues===true) {
                    that.data[seriesName] = _.filter(
                        that.data[seriesName], function(d,i) {
                            return d !== 0;
                        }
                    );
                }
                // if (seriesName==="Story Points") console.log(that.data[seriesName].length);
                // if we do remove values from the data set then we need to save an offset
                // so we are calculating the projection on the revised length
                var dy = that.data[seriesName].length;
                that.indexOffset[seriesName] = dx - dy;

                // calculate an offset between the projected value and the actual accepted values.
                var lastAccepted = that.data[seriesName][that.data[seriesName].length-1];
                var lastProjected = linearProject( that.data[seriesName], that.data[seriesName].length-1);
                // if (seriesName==="Story Points")
                //     console.log("la",lastAccepted,"lp",lastProjected);
                that.pointsOffset[seriesName] = lastAccepted-lastProjected;
            }
            index = index - that.indexOffset[seriesName];
            var y = linearProject( that.data[seriesName], index) + that.pointsOffset[seriesName];
            return Math.round(y * 100) / 100;
        },

        getDerivedFieldsAfterSummary : function () {

            // get the set of projection metrics
            var projectionMetrics = _.filter(self.series,function(s) {
                return s.name.indexOf("Projection")!==-1;
            });

            var metrics = _.map( projectionMetrics, function(m) {
                return {
                    as : m.description,
                    projectOn : m.projectOn,
                    projectFrom : m.projectFrom,
                    name : m.name,
                    f : function(row,index,summaryMetrics,seriesData) {
                        var p = self.calcProjectionPoint(this.name,this.projectOn,row,index,summaryMetrics,seriesData,this.projectFrom);
                        return p;
                    }
                };
            });
            return metrics;

        },

        defined : function(v) {
            return (!_.isUndefined(v) && !_.isNull(v));
        }
    };
   
});

                function LineFitter()
{
    this.count = 0;
    this.sumX = 0;
    this.sumX2 = 0;
    this.sumXY = 0;
    this.sumY = 0;
}

LineFitter.prototype = {
    'add': function(x, y)
    {
        this.count++;
        this.sumX += x;
        this.sumX2 += x*x;
        this.sumXY += x*y;
        this.sumY += y;
    },
    'project': function(x)
    {
        var det = this.count * this.sumX2 - this.sumX * this.sumX;
        var offset = (this.sumX2 * this.sumY - this.sumX * this.sumXY) / det;
        var scale = (this.count * this.sumXY - this.sumX * this.sumY) / det;
        return offset + x * scale;
    }
};

function linearProject(data, x)
{
    var fitter = new LineFitter();
    for (var i = 0; i < data.length; i++)
    {
        fitter.add(i, data[i]);
    }
    return fitter.project(x);
}

function projectToZero( data, x) {

    var start = x;

    while ( linearProject(data,start) > 0)
        start = start + 1;

    return start;

}
                // utility methods

// returns the release name if the app is on a page scoped to a release.
function getReleaseTimeBox(app) {
    var timeboxScope = app.getContext().getTimeboxScope();
    var tbName = null;
    if(timeboxScope) {
        var record = timeboxScope.getRecord();
        tbName = record.get('Name');
    } else {
        tbName = "";
    }
    return tbName;
}

// generic function to perform a web services query    
function wsapiQuery( config , callback ) {
	
    Ext.create('Rally.data.WsapiDataStore', {
        autoLoad : true,
        limit : "Infinity",
        model : config.model,
        fetch : config.fetch,
        filters : config.filters,
        listeners : {
            scope : this,
            load : function(store, data) {
                callback(null,data);
            }
        }
    });
}

function snapshotQuery( config ,callback) {

    var storeConfig = {
        find    : config.find,
        fetch   : config.fetch,
        hydrate : config.hydrate,
        autoLoad : true,
        pageSize : 10000,
        limit    : 'Infinity',
        listeners : {
            scope : this,
            load  : function(store,snapshots,success) {
                console.log("snapshots:",snapshots.length);
                callback(null,snapshots);
            }
        }
    };
    var snapshotStore = Ext.create('Rally.data.lookback.SnapshotStore', storeConfig);

}

function pointsUnitType(type) {
        return type=="Points";
}

function createSeriesArray() {
    return [
        { name : "PreliminaryEstimate",      description : "Preliminary Estimate",  field : "CalcPreliminaryEstimate",    display : "line", f : "sum", color : "Orange" },
        { name : "StoryPoints" ,             description : "Story Points",          field : "LeafStoryPlanEstimateTotal", display : "line", f : "sum", color : "DarkGray" },
        { name : "StoryCount"  ,             description : "Story Count" ,          field : "LeafStoryCount",             display : "line", f : "sum", color : "DarkGray" },
        { name : "StoryPointsProjection",    description : "Scope Projection",  projectOn : "Story Points", color : "LightGray" },
        { name : "StoryCountProjection",     description : "Count Projection",  projectOn : "Story Count",  color : "LightGray" },
        { name : "AcceptedStoryPoints",      description : "Accepted Points",       field : "AcceptedLeafStoryPlanEstimateTotal", display : "line", f : "sum", color : "Green" },
        { name : "AcceptedStoryCount",       description : "Accepted Count",        field : "AcceptedLeafStoryCount",  display : "line", f : "sum", color : "Green" },
        { name : "AcceptedPointsProjection", description : "Accepted Projection", projectOn : "Accepted Points",        color : "LightGray" },
        { name : "AcceptedCountProjection",  description : "Accepted Count Projection", projectOn : "Accepted Count",   color : "LightGray" },
        { name : "FeatureCount",             description : "Feature Count",          field : "ObjectID",                display : "column", f : "count", color : "Blue" },
        { name : "FeatureCountCompleted",    description : "Completed Feature Count",field : "Completed",               display : "column", f : "sum", color : "Green" },
        { name : "HistoricalProjection",     description : "Historical Trend Projection",projectOn : "Accepted Points", color : "LightGray", hidden : true, projectFrom : "mid" },
        { name : "RefinedEstimate" ,         description : "Refined Feature Estimate", field : "RefinedEstimate", display : "line", f : "sum", color : "DarkBlue" }
    ];
}

function createColorsArray( series ) {

    var colors = [];

    _.each( series, function(s,i) {
        if (i>0) {
            var as = _.find( app.series, function(a) {
                return a.description === s.name;
            });
            if (!_.isUndefined(as)) {
                colors.push(as.color);    
            } else {
                colors.push("LightGray");
            }
            
        }
    });

    return colors;

}


function trimHighChartsConfig(hc) {

    // trim future values
    var today = new Date();
    _.each(hc, function(series,i) {
        // for non-projection values dont chart after today
        if (series.name.indexOf("Projection")===-1 && series.name.indexOf("label") ===-1 ) {
            _.each( series.data, function( point , x ){
                if ( Date.parse(hc[0].data[x]) > today )
                    series.data[x] = null;
            });
        }
        // for projection null values before today.
        if (series.name.indexOf("Projection")!==-1) {
            console.log("projection series",series);
            _.each( series.data, function( point , x ){
                if ( Date.parse(hc[0].data[x]) < today ) {
                    series.data[x] = null;

                }
            });
//                series.color = "#C8C8C8";
            series.dashStyle = 'dash';
        }

    });

    return hc;
}

                /** this class will return a set of features which are parented to a specified set of 
  *  portfolio items.
**/
Ext.define("FeaturesForParentStrategy", function() {

    var self;

    return {
        config : {
            portfolioIds : "",
            featureType : "",
            context : ""
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            // trim each value to remove extra spaces
            self.portfolioIds = _.map( self.piArray(), function(s) { return s.trim(); } ).join(",");
            console.log(self.portfolioIds);
            return this;
        },

        piArray : function() {
            return self.portfolioIds.split(",");
        },

        readFeatures : function(callback) {

            Ext.create('Rally.data.WsapiDataStore', {
                autoLoad: true,
                model : "portfolioitem",
                limit : 'Infinity',
                fetch: ['ObjectID','FormattedID','PlannedStartDate','PlannedEndDate'],
                filters: [self.createPIFilter(self.piArray(),"FormattedID")],
                listeners: {
                    load: function(store, parents) {
                        console.log("Loaded:"+parents.length," Parents",parents);
                        // workaround because wsapi return objects of all types
                        parents = _.filter(parents,function(parent) {
                            return (_.indexOf( self.portfolioIds.split(","), parent.get("FormattedID")) !==-1);
                        });                       
                        console.log("Loaded:"+parents.length," Parents",parents);

                        // validate that all were found
                        var diff = _.difference( self.piArray(), _.map(parents,function(p) { 
                            return p.get("FormattedID");
                        }));
                        if (diff.length>0) {
                            callback(null,"The following items were not found:" + diff.join(","));
                            return;
                        }

                        var extent = self.getPortfolioItemExtent(parents)

                        var parentIds = _.map(parents,function(parent) { 
                            return parent.get("ObjectID");
                        });

                        self.getIterations(extent,function(iterations) {
                            self.findFeatureSnapShots(parentIds,function(snapshots) {
                                var featureIds = _.map(snapshots,function(s) { return s.get("ObjectID")});
                                self.getFeatures(featureIds,function(features) {
                                    console.log("features",_.map(features,function(f){return f.get("FormattedID");}));
                                    callback( { features : features, extent : extent, iterations : iterations });
                                });
                            });
                        });
                    }
                }
            });
        },


        createIterationFilter : function(extent) {
            var filter = null;
            var f1 = Ext.create('Rally.data.QueryFilter', {
                property: "StartDate",
                operator: '>=',
                value: extent.isoStart
            });
            var f2 = Ext.create('Rally.data.QueryFilter', {
                property: "EndDate",
                operator: '<=',
                value: extent.isoEnd
            });
            
            var filter = f1.and(f2);
            console.log("iteration filter:",filter.toString());
            return filter;
        },

        createPIFilter : function(ids,field) {
            var filter = null;
            var idsArray = _.isArray(ids) ? ids : ids.split(",");
            _.each(idsArray, function( id, i) {
                var f = Ext.create('Rally.data.QueryFilter', {
                    property: field,
                    operator: '=',
                    value: id
                });
                filter = i === 0 ? f : filter.or(f);
            });
            console.log("filter",filter.toString());
            return filter;
        },

        findFeatureSnapShots : function( parentIds, callback ) {

            console.log("ParentIDs",parentIds);
            var storeConfig = {
                find : {
                    '_TypeHierarchy' : { "$in" : [self.featureType] },
                    '_ItemHierarchy' : { "$in" : parentIds },
                    "__At": "current"
                },
                autoLoad : true,
                pageSize:1000,
                limit: 'Infinity',
                fetch: ['ObjectID','_TypeHierarchy'],
                hydrate: ['_TypeHierarchy'],
                listeners : {
                    scope : this,
                    load: function(store, snapshots, success) {
                        console.log("Loaded:"+snapshots.length," Snapshots.");
                        callback(snapshots);
                    }
                }
            };
            Ext.create('Rally.data.lookback.SnapshotStore', storeConfig);
        },

        // returns the earliest and latest planned start/end dates for the set of items
        getPortfolioItemExtent : function( items ) {

            var startDates = _.compact( _.pluck(items,function(r) { return r.get("PlannedStartDate");}));
            var endDates = _.compact( _.pluck(items,function(r) { return r.get("PlannedEndDate");}));
            var start = _.min(startDates);
            var end   = _.max(endDates);
            var isoStart  = Rally.util.DateTime.toIsoString(start, false);
            var isoEnd    = Rally.util.DateTime.toIsoString(end, false);

            return { start : start, end : end, isoStart : isoStart, isoEnd : isoEnd };
        },

        getIterations : function(extent,callback) {

             Ext.create('Rally.data.WsapiDataStore', {
                autoLoad: true,
                model : "Iteration",
                limit : 'Infinity',
                fetch: ['ObjectID','EndDate','StartDate','Name'],
                filters: [self.createIterationFilter(extent)],
                listeners: {
                    load: function(store, iterations) {
                        console.log("iterations",iterations);
                        callback(iterations);
                    }
                }
            });
        },

        getFeatures : function(featureIds,callback) {

            var filter = self.createPIFilter(featureIds,"ObjectID");
            
            Ext.create('Rally.data.WsapiDataStore', {
                autoLoad: true,
                model : self.featureType,
                limit : 'Infinity',
                fetch: ['ObjectID','FormattedID'],
                filters: [filter],
                listeners: {
                    load: function(store, features) {
                        callback(features);
                    }
                }
            });
        }

    };
   
});


            Rally.launchApp('CustomApp', {
                name:"psi-feature-burnup",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
/* check combo */
.x-combo-checker {
  background-position: 50% -2px;
  margin-left: 1px;
  background-color: transparent;
  background-image: url("https://rally1.rallydev.com/apps/2.0rc1/lib/ext/4.1.1a/resources/themes/images/default/grid/unchecked.gif");
  background-position: -1px -1px;
  background-repeat: no-repeat;
  height: 14px;
  width: 14px;
  display: inline-block;
}
.x-boundlist-selected .x-combo-checker {
  background-image: url("https://rally1.rallydev.com/apps/2.0rc1/lib/ext/4.1.1a/resources/themes/images/default/grid/checked.gif");
}

    </style>
</head>
<body>
</body>
</html>
